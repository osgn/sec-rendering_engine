/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

using System;

namespace Lucene.Net.Documents
{
	
	/// <summary> Provides support for converting dates to strings and vice-versa.
	/// The strings are structured so that lexicographic sorting orders 
	/// them by date, which makes them suitable for use as field values 
	/// and search terms.
	/// 
	/// <P>This class also helps you to limit the resolution of your dates. Do not
	/// save dates with a finer resolution than you really need, as then
	/// RangeQuery and PrefixQuery will require more memory and become slower.
	/// 
	/// <P>Compared to {@link DateField} the strings generated by the methods
	/// in this class take slightly more space, unless your selected resolution
	/// is set to <code>Resolution.DAY</code> or lower.
	/// </summary>
	public class DateTools
	{
		
		// private static readonly System.TimeZone GMT = TimeZone.getTimeZone("GMT");   // {{Aroush-2.1}}
		
		private static readonly System.String YEAR_FORMAT = "yyyy";
		private static readonly System.String MONTH_FORMAT = "yyyyMM";
		private static readonly System.String DAY_FORMAT = "yyyyMMdd";
		private static readonly System.String HOUR_FORMAT = "yyyyMMddHH";
		private static readonly System.String MINUTE_FORMAT = "yyyyMMddHHmm";
		private static readonly System.String SECOND_FORMAT = "yyyyMMddHHmmss";
		private static readonly System.String MILLISECOND_FORMAT = "yyyyMMddHHmmssfff";
		
		// cannot create, the class has static methods only
		private DateTools()
		{
		}
		
		/// <summary> Converts a Date to a string suitable for indexing.
		/// 
		/// </summary>
		/// <param name="date">the date to be converted
		/// </param>
		/// <param name="resolution">the desired resolution, see
		/// {@link #Round(Date, DateTools.Resolution)}
		/// </param>
		/// <returns> a string in format <code>yyyyMMddHHmmssSSS</code> or shorter,
		/// depeding on <code>resolution</code>; using UTC as timezone 
		/// </returns>
		public static System.String DateToString(System.DateTime date, Resolution resolution)
		{
			return TimeToString(date.Ticks, resolution);
		}
		
		/// <summary> Converts a millisecond time to a string suitable for indexing.
		/// 
		/// </summary>
		/// <param name="time">the date expressed as milliseconds since January 1, 1970, 00:00:00 GMT
		/// </param>
		/// <param name="resolution">the desired resolution, see
		/// {@link #Round(long, DateTools.Resolution)}
		/// </param>
		/// <returns> a string in format <code>yyyyMMddHHmmssSSS</code> or shorter,
		/// depeding on <code>resolution</code>; using UTC as timezone
		/// </returns>
		public static System.String TimeToString(long time, Resolution resolution)
		{
			System.Globalization.Calendar cal = new System.Globalization.GregorianCalendar();
			
			//protected in JDK's prior to 1.4
			//cal.setTimeInMillis(round(time, resolution));
			
			System.DateTime dt = new System.DateTime(Round(time, resolution));
			
			System.String result;
			if (resolution == Resolution.YEAR)
			{
				lock (YEAR_FORMAT)
				{
					result = dt.ToString(YEAR_FORMAT);
				}
			}
			else if (resolution == Resolution.MONTH)
			{
				lock (MONTH_FORMAT)
				{
					result = dt.ToString(MONTH_FORMAT);
				}
			}
			else if (resolution == Resolution.DAY)
			{
				lock (DAY_FORMAT)
				{
					result = result = dt.ToString(DAY_FORMAT);
				}
			}
			else if (resolution == Resolution.HOUR)
			{
				lock (HOUR_FORMAT)
				{
					result = result = dt.ToString(HOUR_FORMAT);
				}
			}
			else if (resolution == Resolution.MINUTE)
			{
				lock (MINUTE_FORMAT)
				{
					result = result = dt.ToString(MINUTE_FORMAT);
				}
			}
			else if (resolution == Resolution.SECOND)
			{
				lock (SECOND_FORMAT)
				{
					result = result = dt.ToString(SECOND_FORMAT);
				}
			}
			else if (resolution == Resolution.MILLISECOND)
			{
				lock (MILLISECOND_FORMAT)
				{
					result = result = dt.ToString(MILLISECOND_FORMAT);
				}
			}
			else
			{
				throw new System.ArgumentException("unknown resolution " + resolution);
			}
			return result;
		}
		
		/// <summary> Converts a string produced by <code>timeToString</code> or
		/// <code>dateToString</code> back to a time, represented as the
		/// number of milliseconds since January 1, 1970, 00:00:00 GMT.
		/// 
		/// </summary>
		/// <param name="dateString">the date string to be converted
		/// </param>
		/// <returns> the number of milliseconds since January 1, 1970, 00:00:00 GMT
		/// </returns>
		/// <throws>  ParseException if <code>dateString</code> is not in the  </throws>
		/// <summary>  expected format 
		/// </summary>
		public static long StringToTime(System.String dateString)
		{
			return StringToDate(dateString).Ticks;
		}
		
		/// <summary> Converts a string produced by <code>timeToString</code> or
		/// <code>dateToString</code> back to a time, represented as a
		/// Date object.
		/// 
		/// </summary>
		/// <param name="dateString">the date string to be converted
		/// </param>
		/// <returns> the parsed time as a Date object 
		/// </returns>
		/// <throws>  ParseException if <code>dateString</code> is not in the  </throws>
		/// <summary>  expected format 
		/// </summary>
		public static System.DateTime StringToDate(System.String dateString)
		{
			System.DateTime date;
			if (dateString.Length == 4)
			{
				lock (YEAR_FORMAT)
				{
					date = new System.DateTime(Convert.ToInt16(dateString.Substring(0, 4)),
                        1, 1, 0, 0, 0, 0);
				}
			}
			else if (dateString.Length == 6)
			{
				lock (MONTH_FORMAT)
				{
                    date = new System.DateTime(Convert.ToInt16(dateString.Substring(0, 4)),
                        Convert.ToInt16(dateString.Substring(4, 2)),
                        1, 0, 0, 0, 0);
				}
			}
			else if (dateString.Length == 8)
			{
				lock (DAY_FORMAT)
				{
                    date = new System.DateTime(Convert.ToInt16(dateString.Substring(0, 4)),
                        Convert.ToInt16(dateString.Substring(4, 2)),
                        Convert.ToInt16(dateString.Substring(6, 2)),
                        0, 0, 0, 0);
                }
			}
			else if (dateString.Length == 10)
			{
				lock (HOUR_FORMAT)
				{
                    date = new System.DateTime(Convert.ToInt16(dateString.Substring(0, 4)),
                        Convert.ToInt16(dateString.Substring(4, 2)),
                        Convert.ToInt16(dateString.Substring(6, 2)),
                        Convert.ToInt16(dateString.Substring(8, 2)),
                        0, 0, 0);
                }
			}
			else if (dateString.Length == 12)
			{
				lock (MINUTE_FORMAT)
				{
                    date = new System.DateTime(Convert.ToInt16(dateString.Substring(0, 4)),
                        Convert.ToInt16(dateString.Substring(4, 2)),
                        Convert.ToInt16(dateString.Substring(6, 2)),
                        Convert.ToInt16(dateString.Substring(8, 2)),
                        Convert.ToInt16(dateString.Substring(10, 2)),
                        0, 0);
                }
			}
			else if (dateString.Length == 14)
			{
				lock (SECOND_FORMAT)
				{
                    date = new System.DateTime(Convert.ToInt16(dateString.Substring(0, 4)),
                        Convert.ToInt16(dateString.Substring(4, 2)),
                        Convert.ToInt16(dateString.Substring(6, 2)),
                        Convert.ToInt16(dateString.Substring(8, 2)),
                        Convert.ToInt16(dateString.Substring(10, 2)),
                        Convert.ToInt16(dateString.Substring(12, 2)),
                        0);
                }
			}
			else if (dateString.Length == 17)
			{
				lock (MILLISECOND_FORMAT)
				{
                    date = new System.DateTime(Convert.ToInt16(dateString.Substring(0, 4)),
                        Convert.ToInt16(dateString.Substring(4, 2)),
                        Convert.ToInt16(dateString.Substring(6, 2)),
                        Convert.ToInt16(dateString.Substring(8, 2)),
                        Convert.ToInt16(dateString.Substring(10, 2)),
                        Convert.ToInt16(dateString.Substring(12, 2)),
                        Convert.ToInt16(dateString.Substring(14, 3)));
                }
			}
			else
			{
				throw new System.FormatException("Input is not valid date string: " + dateString);
			}
			return date;
		}
		
		/// <summary> Limit a date's resolution. For example, the date <code>2004-09-21 13:50:11</code>
		/// will be changed to <code>2004-09-01 00:00:00</code> when using
		/// <code>Resolution.MONTH</code>. 
		/// 
		/// </summary>
		/// <param name="resolution">The desired resolution of the date to be returned
		/// </param>
		/// <returns> the date with all values more precise than <code>resolution</code>
		/// set to 0 or 1
		/// </returns>
		public static System.DateTime Round(System.DateTime date, Resolution resolution)
		{
			return new System.DateTime(Round(date.Ticks, resolution));
		}
		
		/// <summary> Limit a date's resolution. For example, the date <code>1095767411000</code>
		/// (which represents 2004-09-21 13:50:11) will be changed to 
		/// <code>1093989600000</code> (2004-09-01 00:00:00) when using
		/// <code>Resolution.MONTH</code>.
		/// 
		/// </summary>
		/// <param name="resolution">The desired resolution of the date to be returned
		/// </param>
		/// <returns> the date with all values more precise than <code>resolution</code>
		/// set to 0 or 1, expressed as milliseconds since January 1, 1970, 00:00:00 GMT
		/// </returns>
		public static long Round(long time, Resolution resolution)
		{
			System.Globalization.Calendar cal = new System.Globalization.GregorianCalendar();   // {{Aroush}} do we care about 'cal'
			
			// protected in JDK's prior to 1.4
			//cal.setTimeInMillis(time);
			
			System.DateTime dt = new System.DateTime(time);
			
			if (resolution == Resolution.YEAR)
			{
                dt = dt.AddMonths(1 - dt.Month);
                dt = dt.AddDays(1 - dt.Day);
                dt = dt.AddHours(0 - dt.Hour);
                dt = dt.AddMinutes(0 - dt.Minute);
                dt = dt.AddSeconds(0 - dt.Second);
                dt = dt.AddMilliseconds(0 - dt.Millisecond);
            }
			else if (resolution == Resolution.MONTH)
			{
                dt = dt.AddDays(1 - dt.Day);
                dt = dt.AddHours(0 - dt.Hour);
                dt = dt.AddMinutes(0 - dt.Minute);
                dt = dt.AddSeconds(0 - dt.Second);
                dt = dt.AddMilliseconds(0 - dt.Millisecond);
            }
			else if (resolution == Resolution.DAY)
			{
                dt = dt.AddHours(0 - dt.Hour);
                dt = dt.AddMinutes(0 - dt.Minute);
                dt = dt.AddSeconds(0 - dt.Second);
                dt = dt.AddMilliseconds(0 - dt.Millisecond);
            }
			else if (resolution == Resolution.HOUR)
			{
                dt = dt.AddMinutes(0 - dt.Minute);
                dt = dt.AddSeconds(0 - dt.Second);
                dt = dt.AddMilliseconds(0 - dt.Millisecond);
            }
			else if (resolution == Resolution.MINUTE)
			{
                dt = dt.AddSeconds(0 - dt.Second);
                dt = dt.AddMilliseconds(0 - dt.Millisecond);
            }
			else if (resolution == Resolution.SECOND)
			{
                dt = dt.AddMilliseconds(0 - dt.Millisecond);
            }
			else if (resolution == Resolution.MILLISECOND)
			{
				// don't cut off anything
			}
			else
			{
				throw new System.ArgumentException("unknown resolution " + resolution);
			}
			return dt.Ticks;
		}
		
		/// <summary>Specifies the time granularity. </summary>
		public class Resolution
		{
			
			public static readonly Resolution YEAR = new Resolution("year");
			public static readonly Resolution MONTH = new Resolution("month");
			public static readonly Resolution DAY = new Resolution("day");
			public static readonly Resolution HOUR = new Resolution("hour");
			public static readonly Resolution MINUTE = new Resolution("minute");
			public static readonly Resolution SECOND = new Resolution("second");
			public static readonly Resolution MILLISECOND = new Resolution("millisecond");
			
			private System.String resolution;
			
			internal Resolution()
			{
			}
			
			internal Resolution(System.String resolution)
			{
				this.resolution = resolution;
			}
			
			public override System.String ToString()
			{
				return resolution;
			}
		}
		static DateTools()
		{
			{
				// times need to be normalized so the value doesn't depend on the 
				// location the index is created/used:
                // {{Aroush-2.1}}
                /*
				YEAR_FORMAT.setTimeZone(GMT);
				MONTH_FORMAT.setTimeZone(GMT);
				DAY_FORMAT.setTimeZone(GMT);
				HOUR_FORMAT.setTimeZone(GMT);
				MINUTE_FORMAT.setTimeZone(GMT);
				SECOND_FORMAT.setTimeZone(GMT);
				MILLISECOND_FORMAT.setTimeZone(GMT);
                */
			}
		}
	}
}